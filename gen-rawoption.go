// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package figtree

import (
	"encoding/json"
	"fmt"
)

// BoolOption hold data for configuration fields of type bool
type BoolOption struct {
	Source  string
	Defined bool
	Value   bool
}

// NewBoolOption returns a default configuration object of type bool
func NewBoolOption(dflt bool) BoolOption {
	return BoolOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewBoolOption are defined by default)
func (o BoolOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *BoolOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *BoolOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type bool) of the option
func (o BoolOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the bool.  This is useful with kingpin option parser
func (o *BoolOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *BoolOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(bool); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type bool.
func (o *BoolOption) SetValue(v interface{}) error {
	if val, ok := v.(bool); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *BoolOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *BoolOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the bool value when marshalling
// the data structure.
func (o BoolOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   bool
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the bool value when marshalling
// the data structure.
func (o BoolOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   bool
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o BoolOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapBoolOption is a map of options.
type MapBoolOption map[string]BoolOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapBoolOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := BoolOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapBoolOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapBoolOption) String() string {
	return fmt.Sprintf("%v", map[string]BoolOption(o))
}

// Map will return a raw map from the Option.
func (o MapBoolOption) Map() map[string]bool {
	tmp := map[string]bool{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapBoolOption) WriteAnswer(name string, value interface{}) error {
	tmp := BoolOption{}
	if v, ok := value.(bool); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapBoolOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListBoolOption is a slice of BoolOption
type ListBoolOption []BoolOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListBoolOption) Set(value string) error {
	val := BoolOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListBoolOption) WriteAnswer(name string, value interface{}) error {
	tmp := BoolOption{}
	if v, ok := value.(bool); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListBoolOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListBoolOption) String() string {
	return fmt.Sprintf("%v", []BoolOption(o))
}

// Append will add the provided bool to the slice with NewBoolOption
func (o ListBoolOption) Append(values ...bool) ListBoolOption {
	results := o
	for _, val := range values {
		results = append(results, NewBoolOption(val))
	}
	return results
}

// Slice returns raw []bool data stored in the ListBoolOption
func (o ListBoolOption) Slice() []bool {
	tmp := []bool{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListBoolOption has one or more options
// in the slice.
func (o ListBoolOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// ByteOption hold data for configuration fields of type byte
type ByteOption struct {
	Source  string
	Defined bool
	Value   byte
}

// NewByteOption returns a default configuration object of type byte
func NewByteOption(dflt byte) ByteOption {
	return ByteOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewByteOption are defined by default)
func (o ByteOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *ByteOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *ByteOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type byte) of the option
func (o ByteOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the byte.  This is useful with kingpin option parser
func (o *ByteOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ByteOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(byte); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type byte.
func (o *ByteOption) SetValue(v interface{}) error {
	if val, ok := v.(byte); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *ByteOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *ByteOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the byte value when marshalling
// the data structure.
func (o ByteOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   byte
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the byte value when marshalling
// the data structure.
func (o ByteOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   byte
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o ByteOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapByteOption is a map of options.
type MapByteOption map[string]ByteOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapByteOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := ByteOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapByteOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapByteOption) String() string {
	return fmt.Sprintf("%v", map[string]ByteOption(o))
}

// Map will return a raw map from the Option.
func (o MapByteOption) Map() map[string]byte {
	tmp := map[string]byte{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapByteOption) WriteAnswer(name string, value interface{}) error {
	tmp := ByteOption{}
	if v, ok := value.(byte); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapByteOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListByteOption is a slice of ByteOption
type ListByteOption []ByteOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListByteOption) Set(value string) error {
	val := ByteOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListByteOption) WriteAnswer(name string, value interface{}) error {
	tmp := ByteOption{}
	if v, ok := value.(byte); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListByteOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListByteOption) String() string {
	return fmt.Sprintf("%v", []ByteOption(o))
}

// Append will add the provided byte to the slice with NewByteOption
func (o ListByteOption) Append(values ...byte) ListByteOption {
	results := o
	for _, val := range values {
		results = append(results, NewByteOption(val))
	}
	return results
}

// Slice returns raw []byte data stored in the ListByteOption
func (o ListByteOption) Slice() []byte {
	tmp := []byte{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListByteOption has one or more options
// in the slice.
func (o ListByteOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Complex128Option hold data for configuration fields of type complex128
type Complex128Option struct {
	Source  string
	Defined bool
	Value   complex128
}

// NewComplex128Option returns a default configuration object of type complex128
func NewComplex128Option(dflt complex128) Complex128Option {
	return Complex128Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewComplex128Option are defined by default)
func (o Complex128Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Complex128Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Complex128Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type complex128) of the option
func (o Complex128Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the complex128.  This is useful with kingpin option parser
func (o *Complex128Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Complex128Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(complex128); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type complex128.
func (o *Complex128Option) SetValue(v interface{}) error {
	if val, ok := v.(complex128); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Complex128Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Complex128Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the complex128 value when marshalling
// the data structure.
func (o Complex128Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   complex128
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the complex128 value when marshalling
// the data structure.
func (o Complex128Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   complex128
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Complex128Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapComplex128Option is a map of options.
type MapComplex128Option map[string]Complex128Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapComplex128Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Complex128Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapComplex128Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapComplex128Option) String() string {
	return fmt.Sprintf("%v", map[string]Complex128Option(o))
}

// Map will return a raw map from the Option.
func (o MapComplex128Option) Map() map[string]complex128 {
	tmp := map[string]complex128{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapComplex128Option) WriteAnswer(name string, value interface{}) error {
	tmp := Complex128Option{}
	if v, ok := value.(complex128); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapComplex128Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListComplex128Option is a slice of Complex128Option
type ListComplex128Option []Complex128Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListComplex128Option) Set(value string) error {
	val := Complex128Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListComplex128Option) WriteAnswer(name string, value interface{}) error {
	tmp := Complex128Option{}
	if v, ok := value.(complex128); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListComplex128Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListComplex128Option) String() string {
	return fmt.Sprintf("%v", []Complex128Option(o))
}

// Append will add the provided complex128 to the slice with NewComplex128Option
func (o ListComplex128Option) Append(values ...complex128) ListComplex128Option {
	results := o
	for _, val := range values {
		results = append(results, NewComplex128Option(val))
	}
	return results
}

// Slice returns raw []complex128 data stored in the ListComplex128Option
func (o ListComplex128Option) Slice() []complex128 {
	tmp := []complex128{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListComplex128Option has one or more options
// in the slice.
func (o ListComplex128Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Complex64Option hold data for configuration fields of type complex64
type Complex64Option struct {
	Source  string
	Defined bool
	Value   complex64
}

// NewComplex64Option returns a default configuration object of type complex64
func NewComplex64Option(dflt complex64) Complex64Option {
	return Complex64Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewComplex64Option are defined by default)
func (o Complex64Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Complex64Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Complex64Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type complex64) of the option
func (o Complex64Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the complex64.  This is useful with kingpin option parser
func (o *Complex64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Complex64Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(complex64); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type complex64.
func (o *Complex64Option) SetValue(v interface{}) error {
	if val, ok := v.(complex64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Complex64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Complex64Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the complex64 value when marshalling
// the data structure.
func (o Complex64Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   complex64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the complex64 value when marshalling
// the data structure.
func (o Complex64Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   complex64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Complex64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapComplex64Option is a map of options.
type MapComplex64Option map[string]Complex64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapComplex64Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Complex64Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapComplex64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapComplex64Option) String() string {
	return fmt.Sprintf("%v", map[string]Complex64Option(o))
}

// Map will return a raw map from the Option.
func (o MapComplex64Option) Map() map[string]complex64 {
	tmp := map[string]complex64{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapComplex64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Complex64Option{}
	if v, ok := value.(complex64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapComplex64Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListComplex64Option is a slice of Complex64Option
type ListComplex64Option []Complex64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListComplex64Option) Set(value string) error {
	val := Complex64Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListComplex64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Complex64Option{}
	if v, ok := value.(complex64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListComplex64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListComplex64Option) String() string {
	return fmt.Sprintf("%v", []Complex64Option(o))
}

// Append will add the provided complex64 to the slice with NewComplex64Option
func (o ListComplex64Option) Append(values ...complex64) ListComplex64Option {
	results := o
	for _, val := range values {
		results = append(results, NewComplex64Option(val))
	}
	return results
}

// Slice returns raw []complex64 data stored in the ListComplex64Option
func (o ListComplex64Option) Slice() []complex64 {
	tmp := []complex64{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListComplex64Option has one or more options
// in the slice.
func (o ListComplex64Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// ErrorOption hold data for configuration fields of type error
type ErrorOption struct {
	Source  string
	Defined bool
	Value   error
}

// NewErrorOption returns a default configuration object of type error
func NewErrorOption(dflt error) ErrorOption {
	return ErrorOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewErrorOption are defined by default)
func (o ErrorOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *ErrorOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *ErrorOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type error) of the option
func (o ErrorOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the error.  This is useful with kingpin option parser
func (o *ErrorOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ErrorOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(error); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type error.
func (o *ErrorOption) SetValue(v interface{}) error {
	if val, ok := v.(error); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *ErrorOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *ErrorOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the error value when marshalling
// the data structure.
func (o ErrorOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   error
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the error value when marshalling
// the data structure.
func (o ErrorOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   error
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o ErrorOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapErrorOption is a map of options.
type MapErrorOption map[string]ErrorOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapErrorOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := ErrorOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapErrorOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapErrorOption) String() string {
	return fmt.Sprintf("%v", map[string]ErrorOption(o))
}

// Map will return a raw map from the Option.
func (o MapErrorOption) Map() map[string]error {
	tmp := map[string]error{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapErrorOption) WriteAnswer(name string, value interface{}) error {
	tmp := ErrorOption{}
	if v, ok := value.(error); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapErrorOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListErrorOption is a slice of ErrorOption
type ListErrorOption []ErrorOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListErrorOption) Set(value string) error {
	val := ErrorOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListErrorOption) WriteAnswer(name string, value interface{}) error {
	tmp := ErrorOption{}
	if v, ok := value.(error); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListErrorOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListErrorOption) String() string {
	return fmt.Sprintf("%v", []ErrorOption(o))
}

// Append will add the provided error to the slice with NewErrorOption
func (o ListErrorOption) Append(values ...error) ListErrorOption {
	results := o
	for _, val := range values {
		results = append(results, NewErrorOption(val))
	}
	return results
}

// Slice returns raw []error data stored in the ListErrorOption
func (o ListErrorOption) Slice() []error {
	tmp := []error{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListErrorOption has one or more options
// in the slice.
func (o ListErrorOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Float32Option hold data for configuration fields of type float32
type Float32Option struct {
	Source  string
	Defined bool
	Value   float32
}

// NewFloat32Option returns a default configuration object of type float32
func NewFloat32Option(dflt float32) Float32Option {
	return Float32Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewFloat32Option are defined by default)
func (o Float32Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Float32Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Float32Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type float32) of the option
func (o Float32Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the float32.  This is useful with kingpin option parser
func (o *Float32Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Float32Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(float32); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type float32.
func (o *Float32Option) SetValue(v interface{}) error {
	if val, ok := v.(float32); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Float32Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Float32Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the float32 value when marshalling
// the data structure.
func (o Float32Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   float32
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the float32 value when marshalling
// the data structure.
func (o Float32Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   float32
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Float32Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapFloat32Option is a map of options.
type MapFloat32Option map[string]Float32Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapFloat32Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Float32Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapFloat32Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapFloat32Option) String() string {
	return fmt.Sprintf("%v", map[string]Float32Option(o))
}

// Map will return a raw map from the Option.
func (o MapFloat32Option) Map() map[string]float32 {
	tmp := map[string]float32{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapFloat32Option) WriteAnswer(name string, value interface{}) error {
	tmp := Float32Option{}
	if v, ok := value.(float32); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapFloat32Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListFloat32Option is a slice of Float32Option
type ListFloat32Option []Float32Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListFloat32Option) Set(value string) error {
	val := Float32Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListFloat32Option) WriteAnswer(name string, value interface{}) error {
	tmp := Float32Option{}
	if v, ok := value.(float32); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListFloat32Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListFloat32Option) String() string {
	return fmt.Sprintf("%v", []Float32Option(o))
}

// Append will add the provided float32 to the slice with NewFloat32Option
func (o ListFloat32Option) Append(values ...float32) ListFloat32Option {
	results := o
	for _, val := range values {
		results = append(results, NewFloat32Option(val))
	}
	return results
}

// Slice returns raw []float32 data stored in the ListFloat32Option
func (o ListFloat32Option) Slice() []float32 {
	tmp := []float32{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListFloat32Option has one or more options
// in the slice.
func (o ListFloat32Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Float64Option hold data for configuration fields of type float64
type Float64Option struct {
	Source  string
	Defined bool
	Value   float64
}

// NewFloat64Option returns a default configuration object of type float64
func NewFloat64Option(dflt float64) Float64Option {
	return Float64Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewFloat64Option are defined by default)
func (o Float64Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Float64Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Float64Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type float64) of the option
func (o Float64Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the float64.  This is useful with kingpin option parser
func (o *Float64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Float64Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(float64); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type float64.
func (o *Float64Option) SetValue(v interface{}) error {
	if val, ok := v.(float64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Float64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Float64Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the float64 value when marshalling
// the data structure.
func (o Float64Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   float64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the float64 value when marshalling
// the data structure.
func (o Float64Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   float64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Float64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapFloat64Option is a map of options.
type MapFloat64Option map[string]Float64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapFloat64Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Float64Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapFloat64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapFloat64Option) String() string {
	return fmt.Sprintf("%v", map[string]Float64Option(o))
}

// Map will return a raw map from the Option.
func (o MapFloat64Option) Map() map[string]float64 {
	tmp := map[string]float64{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapFloat64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Float64Option{}
	if v, ok := value.(float64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapFloat64Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListFloat64Option is a slice of Float64Option
type ListFloat64Option []Float64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListFloat64Option) Set(value string) error {
	val := Float64Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListFloat64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Float64Option{}
	if v, ok := value.(float64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListFloat64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListFloat64Option) String() string {
	return fmt.Sprintf("%v", []Float64Option(o))
}

// Append will add the provided float64 to the slice with NewFloat64Option
func (o ListFloat64Option) Append(values ...float64) ListFloat64Option {
	results := o
	for _, val := range values {
		results = append(results, NewFloat64Option(val))
	}
	return results
}

// Slice returns raw []float64 data stored in the ListFloat64Option
func (o ListFloat64Option) Slice() []float64 {
	tmp := []float64{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListFloat64Option has one or more options
// in the slice.
func (o ListFloat64Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// IntOption hold data for configuration fields of type int
type IntOption struct {
	Source  string
	Defined bool
	Value   int
}

// NewIntOption returns a default configuration object of type int
func NewIntOption(dflt int) IntOption {
	return IntOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewIntOption are defined by default)
func (o IntOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *IntOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *IntOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type int) of the option
func (o IntOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the int.  This is useful with kingpin option parser
func (o *IntOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *IntOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(int); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type int.
func (o *IntOption) SetValue(v interface{}) error {
	if val, ok := v.(int); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *IntOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *IntOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the int value when marshalling
// the data structure.
func (o IntOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   int
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the int value when marshalling
// the data structure.
func (o IntOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   int
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o IntOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapIntOption is a map of options.
type MapIntOption map[string]IntOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapIntOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := IntOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapIntOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapIntOption) String() string {
	return fmt.Sprintf("%v", map[string]IntOption(o))
}

// Map will return a raw map from the Option.
func (o MapIntOption) Map() map[string]int {
	tmp := map[string]int{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapIntOption) WriteAnswer(name string, value interface{}) error {
	tmp := IntOption{}
	if v, ok := value.(int); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapIntOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListIntOption is a slice of IntOption
type ListIntOption []IntOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListIntOption) Set(value string) error {
	val := IntOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListIntOption) WriteAnswer(name string, value interface{}) error {
	tmp := IntOption{}
	if v, ok := value.(int); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListIntOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListIntOption) String() string {
	return fmt.Sprintf("%v", []IntOption(o))
}

// Append will add the provided int to the slice with NewIntOption
func (o ListIntOption) Append(values ...int) ListIntOption {
	results := o
	for _, val := range values {
		results = append(results, NewIntOption(val))
	}
	return results
}

// Slice returns raw []int data stored in the ListIntOption
func (o ListIntOption) Slice() []int {
	tmp := []int{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListIntOption has one or more options
// in the slice.
func (o ListIntOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Int16Option hold data for configuration fields of type int16
type Int16Option struct {
	Source  string
	Defined bool
	Value   int16
}

// NewInt16Option returns a default configuration object of type int16
func NewInt16Option(dflt int16) Int16Option {
	return Int16Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewInt16Option are defined by default)
func (o Int16Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Int16Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Int16Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type int16) of the option
func (o Int16Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the int16.  This is useful with kingpin option parser
func (o *Int16Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Int16Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(int16); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type int16.
func (o *Int16Option) SetValue(v interface{}) error {
	if val, ok := v.(int16); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Int16Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Int16Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the int16 value when marshalling
// the data structure.
func (o Int16Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   int16
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the int16 value when marshalling
// the data structure.
func (o Int16Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   int16
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Int16Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapInt16Option is a map of options.
type MapInt16Option map[string]Int16Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapInt16Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Int16Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapInt16Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapInt16Option) String() string {
	return fmt.Sprintf("%v", map[string]Int16Option(o))
}

// Map will return a raw map from the Option.
func (o MapInt16Option) Map() map[string]int16 {
	tmp := map[string]int16{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapInt16Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int16Option{}
	if v, ok := value.(int16); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapInt16Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListInt16Option is a slice of Int16Option
type ListInt16Option []Int16Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListInt16Option) Set(value string) error {
	val := Int16Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListInt16Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int16Option{}
	if v, ok := value.(int16); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListInt16Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListInt16Option) String() string {
	return fmt.Sprintf("%v", []Int16Option(o))
}

// Append will add the provided int16 to the slice with NewInt16Option
func (o ListInt16Option) Append(values ...int16) ListInt16Option {
	results := o
	for _, val := range values {
		results = append(results, NewInt16Option(val))
	}
	return results
}

// Slice returns raw []int16 data stored in the ListInt16Option
func (o ListInt16Option) Slice() []int16 {
	tmp := []int16{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListInt16Option has one or more options
// in the slice.
func (o ListInt16Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Int32Option hold data for configuration fields of type int32
type Int32Option struct {
	Source  string
	Defined bool
	Value   int32
}

// NewInt32Option returns a default configuration object of type int32
func NewInt32Option(dflt int32) Int32Option {
	return Int32Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewInt32Option are defined by default)
func (o Int32Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Int32Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Int32Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type int32) of the option
func (o Int32Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the int32.  This is useful with kingpin option parser
func (o *Int32Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Int32Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(int32); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type int32.
func (o *Int32Option) SetValue(v interface{}) error {
	if val, ok := v.(int32); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Int32Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Int32Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the int32 value when marshalling
// the data structure.
func (o Int32Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   int32
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the int32 value when marshalling
// the data structure.
func (o Int32Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   int32
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Int32Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapInt32Option is a map of options.
type MapInt32Option map[string]Int32Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapInt32Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Int32Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapInt32Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapInt32Option) String() string {
	return fmt.Sprintf("%v", map[string]Int32Option(o))
}

// Map will return a raw map from the Option.
func (o MapInt32Option) Map() map[string]int32 {
	tmp := map[string]int32{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapInt32Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int32Option{}
	if v, ok := value.(int32); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapInt32Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListInt32Option is a slice of Int32Option
type ListInt32Option []Int32Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListInt32Option) Set(value string) error {
	val := Int32Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListInt32Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int32Option{}
	if v, ok := value.(int32); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListInt32Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListInt32Option) String() string {
	return fmt.Sprintf("%v", []Int32Option(o))
}

// Append will add the provided int32 to the slice with NewInt32Option
func (o ListInt32Option) Append(values ...int32) ListInt32Option {
	results := o
	for _, val := range values {
		results = append(results, NewInt32Option(val))
	}
	return results
}

// Slice returns raw []int32 data stored in the ListInt32Option
func (o ListInt32Option) Slice() []int32 {
	tmp := []int32{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListInt32Option has one or more options
// in the slice.
func (o ListInt32Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Int64Option hold data for configuration fields of type int64
type Int64Option struct {
	Source  string
	Defined bool
	Value   int64
}

// NewInt64Option returns a default configuration object of type int64
func NewInt64Option(dflt int64) Int64Option {
	return Int64Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewInt64Option are defined by default)
func (o Int64Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Int64Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Int64Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type int64) of the option
func (o Int64Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the int64.  This is useful with kingpin option parser
func (o *Int64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Int64Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(int64); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type int64.
func (o *Int64Option) SetValue(v interface{}) error {
	if val, ok := v.(int64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Int64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Int64Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the int64 value when marshalling
// the data structure.
func (o Int64Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   int64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the int64 value when marshalling
// the data structure.
func (o Int64Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   int64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Int64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapInt64Option is a map of options.
type MapInt64Option map[string]Int64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapInt64Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Int64Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapInt64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapInt64Option) String() string {
	return fmt.Sprintf("%v", map[string]Int64Option(o))
}

// Map will return a raw map from the Option.
func (o MapInt64Option) Map() map[string]int64 {
	tmp := map[string]int64{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapInt64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int64Option{}
	if v, ok := value.(int64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapInt64Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListInt64Option is a slice of Int64Option
type ListInt64Option []Int64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListInt64Option) Set(value string) error {
	val := Int64Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListInt64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int64Option{}
	if v, ok := value.(int64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListInt64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListInt64Option) String() string {
	return fmt.Sprintf("%v", []Int64Option(o))
}

// Append will add the provided int64 to the slice with NewInt64Option
func (o ListInt64Option) Append(values ...int64) ListInt64Option {
	results := o
	for _, val := range values {
		results = append(results, NewInt64Option(val))
	}
	return results
}

// Slice returns raw []int64 data stored in the ListInt64Option
func (o ListInt64Option) Slice() []int64 {
	tmp := []int64{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListInt64Option has one or more options
// in the slice.
func (o ListInt64Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Int8Option hold data for configuration fields of type int8
type Int8Option struct {
	Source  string
	Defined bool
	Value   int8
}

// NewInt8Option returns a default configuration object of type int8
func NewInt8Option(dflt int8) Int8Option {
	return Int8Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewInt8Option are defined by default)
func (o Int8Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Int8Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Int8Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type int8) of the option
func (o Int8Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the int8.  This is useful with kingpin option parser
func (o *Int8Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Int8Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(int8); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type int8.
func (o *Int8Option) SetValue(v interface{}) error {
	if val, ok := v.(int8); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Int8Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Int8Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the int8 value when marshalling
// the data structure.
func (o Int8Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   int8
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the int8 value when marshalling
// the data structure.
func (o Int8Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   int8
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Int8Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapInt8Option is a map of options.
type MapInt8Option map[string]Int8Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapInt8Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Int8Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapInt8Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapInt8Option) String() string {
	return fmt.Sprintf("%v", map[string]Int8Option(o))
}

// Map will return a raw map from the Option.
func (o MapInt8Option) Map() map[string]int8 {
	tmp := map[string]int8{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapInt8Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int8Option{}
	if v, ok := value.(int8); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapInt8Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListInt8Option is a slice of Int8Option
type ListInt8Option []Int8Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListInt8Option) Set(value string) error {
	val := Int8Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListInt8Option) WriteAnswer(name string, value interface{}) error {
	tmp := Int8Option{}
	if v, ok := value.(int8); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListInt8Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListInt8Option) String() string {
	return fmt.Sprintf("%v", []Int8Option(o))
}

// Append will add the provided int8 to the slice with NewInt8Option
func (o ListInt8Option) Append(values ...int8) ListInt8Option {
	results := o
	for _, val := range values {
		results = append(results, NewInt8Option(val))
	}
	return results
}

// Slice returns raw []int8 data stored in the ListInt8Option
func (o ListInt8Option) Slice() []int8 {
	tmp := []int8{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListInt8Option has one or more options
// in the slice.
func (o ListInt8Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// RuneOption hold data for configuration fields of type rune
type RuneOption struct {
	Source  string
	Defined bool
	Value   rune
}

// NewRuneOption returns a default configuration object of type rune
func NewRuneOption(dflt rune) RuneOption {
	return RuneOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewRuneOption are defined by default)
func (o RuneOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *RuneOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *RuneOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type rune) of the option
func (o RuneOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the rune.  This is useful with kingpin option parser
func (o *RuneOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *RuneOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(rune); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type rune.
func (o *RuneOption) SetValue(v interface{}) error {
	if val, ok := v.(rune); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *RuneOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *RuneOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the rune value when marshalling
// the data structure.
func (o RuneOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   rune
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the rune value when marshalling
// the data structure.
func (o RuneOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   rune
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o RuneOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapRuneOption is a map of options.
type MapRuneOption map[string]RuneOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapRuneOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := RuneOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapRuneOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapRuneOption) String() string {
	return fmt.Sprintf("%v", map[string]RuneOption(o))
}

// Map will return a raw map from the Option.
func (o MapRuneOption) Map() map[string]rune {
	tmp := map[string]rune{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapRuneOption) WriteAnswer(name string, value interface{}) error {
	tmp := RuneOption{}
	if v, ok := value.(rune); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapRuneOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListRuneOption is a slice of RuneOption
type ListRuneOption []RuneOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListRuneOption) Set(value string) error {
	val := RuneOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListRuneOption) WriteAnswer(name string, value interface{}) error {
	tmp := RuneOption{}
	if v, ok := value.(rune); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListRuneOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListRuneOption) String() string {
	return fmt.Sprintf("%v", []RuneOption(o))
}

// Append will add the provided rune to the slice with NewRuneOption
func (o ListRuneOption) Append(values ...rune) ListRuneOption {
	results := o
	for _, val := range values {
		results = append(results, NewRuneOption(val))
	}
	return results
}

// Slice returns raw []rune data stored in the ListRuneOption
func (o ListRuneOption) Slice() []rune {
	tmp := []rune{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListRuneOption has one or more options
// in the slice.
func (o ListRuneOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// StringOption hold data for configuration fields of type string
type StringOption struct {
	Source  string
	Defined bool
	Value   string
}

// NewStringOption returns a default configuration object of type string
func NewStringOption(dflt string) StringOption {
	return StringOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewStringOption are defined by default)
func (o StringOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *StringOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *StringOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type string) of the option
func (o StringOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the string.  This is useful with kingpin option parser
func (o *StringOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *StringOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(string); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type string.
func (o *StringOption) SetValue(v interface{}) error {
	if val, ok := v.(string); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *StringOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *StringOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the string value when marshalling
// the data structure.
func (o StringOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   string
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the string value when marshalling
// the data structure.
func (o StringOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   string
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o StringOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapStringOption is a map of options.
type MapStringOption map[string]StringOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapStringOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := StringOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapStringOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapStringOption) String() string {
	return fmt.Sprintf("%v", map[string]StringOption(o))
}

// Map will return a raw map from the Option.
func (o MapStringOption) Map() map[string]string {
	tmp := map[string]string{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapStringOption) WriteAnswer(name string, value interface{}) error {
	tmp := StringOption{}
	if v, ok := value.(string); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapStringOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListStringOption is a slice of StringOption
type ListStringOption []StringOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListStringOption) Set(value string) error {
	val := StringOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListStringOption) WriteAnswer(name string, value interface{}) error {
	tmp := StringOption{}
	if v, ok := value.(string); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListStringOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListStringOption) String() string {
	return fmt.Sprintf("%v", []StringOption(o))
}

// Append will add the provided string to the slice with NewStringOption
func (o ListStringOption) Append(values ...string) ListStringOption {
	results := o
	for _, val := range values {
		results = append(results, NewStringOption(val))
	}
	return results
}

// Slice returns raw []string data stored in the ListStringOption
func (o ListStringOption) Slice() []string {
	tmp := []string{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListStringOption has one or more options
// in the slice.
func (o ListStringOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// UintOption hold data for configuration fields of type uint
type UintOption struct {
	Source  string
	Defined bool
	Value   uint
}

// NewUintOption returns a default configuration object of type uint
func NewUintOption(dflt uint) UintOption {
	return UintOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewUintOption are defined by default)
func (o UintOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *UintOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *UintOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type uint) of the option
func (o UintOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the uint.  This is useful with kingpin option parser
func (o *UintOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *UintOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(uint); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type uint.
func (o *UintOption) SetValue(v interface{}) error {
	if val, ok := v.(uint); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *UintOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *UintOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the uint value when marshalling
// the data structure.
func (o UintOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   uint
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the uint value when marshalling
// the data structure.
func (o UintOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   uint
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o UintOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapUintOption is a map of options.
type MapUintOption map[string]UintOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapUintOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := UintOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapUintOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapUintOption) String() string {
	return fmt.Sprintf("%v", map[string]UintOption(o))
}

// Map will return a raw map from the Option.
func (o MapUintOption) Map() map[string]uint {
	tmp := map[string]uint{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapUintOption) WriteAnswer(name string, value interface{}) error {
	tmp := UintOption{}
	if v, ok := value.(uint); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapUintOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListUintOption is a slice of UintOption
type ListUintOption []UintOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListUintOption) Set(value string) error {
	val := UintOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListUintOption) WriteAnswer(name string, value interface{}) error {
	tmp := UintOption{}
	if v, ok := value.(uint); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListUintOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListUintOption) String() string {
	return fmt.Sprintf("%v", []UintOption(o))
}

// Append will add the provided uint to the slice with NewUintOption
func (o ListUintOption) Append(values ...uint) ListUintOption {
	results := o
	for _, val := range values {
		results = append(results, NewUintOption(val))
	}
	return results
}

// Slice returns raw []uint data stored in the ListUintOption
func (o ListUintOption) Slice() []uint {
	tmp := []uint{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListUintOption has one or more options
// in the slice.
func (o ListUintOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Uint16Option hold data for configuration fields of type uint16
type Uint16Option struct {
	Source  string
	Defined bool
	Value   uint16
}

// NewUint16Option returns a default configuration object of type uint16
func NewUint16Option(dflt uint16) Uint16Option {
	return Uint16Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewUint16Option are defined by default)
func (o Uint16Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Uint16Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Uint16Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type uint16) of the option
func (o Uint16Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the uint16.  This is useful with kingpin option parser
func (o *Uint16Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Uint16Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(uint16); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type uint16.
func (o *Uint16Option) SetValue(v interface{}) error {
	if val, ok := v.(uint16); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Uint16Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Uint16Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the uint16 value when marshalling
// the data structure.
func (o Uint16Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   uint16
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the uint16 value when marshalling
// the data structure.
func (o Uint16Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   uint16
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Uint16Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapUint16Option is a map of options.
type MapUint16Option map[string]Uint16Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapUint16Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Uint16Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapUint16Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapUint16Option) String() string {
	return fmt.Sprintf("%v", map[string]Uint16Option(o))
}

// Map will return a raw map from the Option.
func (o MapUint16Option) Map() map[string]uint16 {
	tmp := map[string]uint16{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapUint16Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint16Option{}
	if v, ok := value.(uint16); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapUint16Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListUint16Option is a slice of Uint16Option
type ListUint16Option []Uint16Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListUint16Option) Set(value string) error {
	val := Uint16Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListUint16Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint16Option{}
	if v, ok := value.(uint16); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListUint16Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListUint16Option) String() string {
	return fmt.Sprintf("%v", []Uint16Option(o))
}

// Append will add the provided uint16 to the slice with NewUint16Option
func (o ListUint16Option) Append(values ...uint16) ListUint16Option {
	results := o
	for _, val := range values {
		results = append(results, NewUint16Option(val))
	}
	return results
}

// Slice returns raw []uint16 data stored in the ListUint16Option
func (o ListUint16Option) Slice() []uint16 {
	tmp := []uint16{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListUint16Option has one or more options
// in the slice.
func (o ListUint16Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Uint32Option hold data for configuration fields of type uint32
type Uint32Option struct {
	Source  string
	Defined bool
	Value   uint32
}

// NewUint32Option returns a default configuration object of type uint32
func NewUint32Option(dflt uint32) Uint32Option {
	return Uint32Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewUint32Option are defined by default)
func (o Uint32Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Uint32Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Uint32Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type uint32) of the option
func (o Uint32Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the uint32.  This is useful with kingpin option parser
func (o *Uint32Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Uint32Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(uint32); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type uint32.
func (o *Uint32Option) SetValue(v interface{}) error {
	if val, ok := v.(uint32); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Uint32Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Uint32Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the uint32 value when marshalling
// the data structure.
func (o Uint32Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   uint32
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the uint32 value when marshalling
// the data structure.
func (o Uint32Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   uint32
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Uint32Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapUint32Option is a map of options.
type MapUint32Option map[string]Uint32Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapUint32Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Uint32Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapUint32Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapUint32Option) String() string {
	return fmt.Sprintf("%v", map[string]Uint32Option(o))
}

// Map will return a raw map from the Option.
func (o MapUint32Option) Map() map[string]uint32 {
	tmp := map[string]uint32{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapUint32Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint32Option{}
	if v, ok := value.(uint32); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapUint32Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListUint32Option is a slice of Uint32Option
type ListUint32Option []Uint32Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListUint32Option) Set(value string) error {
	val := Uint32Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListUint32Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint32Option{}
	if v, ok := value.(uint32); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListUint32Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListUint32Option) String() string {
	return fmt.Sprintf("%v", []Uint32Option(o))
}

// Append will add the provided uint32 to the slice with NewUint32Option
func (o ListUint32Option) Append(values ...uint32) ListUint32Option {
	results := o
	for _, val := range values {
		results = append(results, NewUint32Option(val))
	}
	return results
}

// Slice returns raw []uint32 data stored in the ListUint32Option
func (o ListUint32Option) Slice() []uint32 {
	tmp := []uint32{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListUint32Option has one or more options
// in the slice.
func (o ListUint32Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Uint64Option hold data for configuration fields of type uint64
type Uint64Option struct {
	Source  string
	Defined bool
	Value   uint64
}

// NewUint64Option returns a default configuration object of type uint64
func NewUint64Option(dflt uint64) Uint64Option {
	return Uint64Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewUint64Option are defined by default)
func (o Uint64Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Uint64Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Uint64Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type uint64) of the option
func (o Uint64Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the uint64.  This is useful with kingpin option parser
func (o *Uint64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Uint64Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(uint64); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type uint64.
func (o *Uint64Option) SetValue(v interface{}) error {
	if val, ok := v.(uint64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Uint64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Uint64Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the uint64 value when marshalling
// the data structure.
func (o Uint64Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   uint64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the uint64 value when marshalling
// the data structure.
func (o Uint64Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   uint64
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Uint64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapUint64Option is a map of options.
type MapUint64Option map[string]Uint64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapUint64Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Uint64Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapUint64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapUint64Option) String() string {
	return fmt.Sprintf("%v", map[string]Uint64Option(o))
}

// Map will return a raw map from the Option.
func (o MapUint64Option) Map() map[string]uint64 {
	tmp := map[string]uint64{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapUint64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint64Option{}
	if v, ok := value.(uint64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapUint64Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListUint64Option is a slice of Uint64Option
type ListUint64Option []Uint64Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListUint64Option) Set(value string) error {
	val := Uint64Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListUint64Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint64Option{}
	if v, ok := value.(uint64); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListUint64Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListUint64Option) String() string {
	return fmt.Sprintf("%v", []Uint64Option(o))
}

// Append will add the provided uint64 to the slice with NewUint64Option
func (o ListUint64Option) Append(values ...uint64) ListUint64Option {
	results := o
	for _, val := range values {
		results = append(results, NewUint64Option(val))
	}
	return results
}

// Slice returns raw []uint64 data stored in the ListUint64Option
func (o ListUint64Option) Slice() []uint64 {
	tmp := []uint64{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListUint64Option has one or more options
// in the slice.
func (o ListUint64Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// Uint8Option hold data for configuration fields of type uint8
type Uint8Option struct {
	Source  string
	Defined bool
	Value   uint8
}

// NewUint8Option returns a default configuration object of type uint8
func NewUint8Option(dflt uint8) Uint8Option {
	return Uint8Option{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewUint8Option are defined by default)
func (o Uint8Option) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *Uint8Option) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *Uint8Option) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type uint8) of the option
func (o Uint8Option) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the uint8.  This is useful with kingpin option parser
func (o *Uint8Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *Uint8Option) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(uint8); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type uint8.
func (o *Uint8Option) SetValue(v interface{}) error {
	if val, ok := v.(uint8); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *Uint8Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *Uint8Option) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the uint8 value when marshalling
// the data structure.
func (o Uint8Option) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   uint8
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the uint8 value when marshalling
// the data structure.
func (o Uint8Option) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   uint8
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o Uint8Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapUint8Option is a map of options.
type MapUint8Option map[string]Uint8Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapUint8Option) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := Uint8Option{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapUint8Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapUint8Option) String() string {
	return fmt.Sprintf("%v", map[string]Uint8Option(o))
}

// Map will return a raw map from the Option.
func (o MapUint8Option) Map() map[string]uint8 {
	tmp := map[string]uint8{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapUint8Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint8Option{}
	if v, ok := value.(uint8); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapUint8Option) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListUint8Option is a slice of Uint8Option
type ListUint8Option []Uint8Option

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListUint8Option) Set(value string) error {
	val := Uint8Option{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListUint8Option) WriteAnswer(name string, value interface{}) error {
	tmp := Uint8Option{}
	if v, ok := value.(uint8); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListUint8Option) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListUint8Option) String() string {
	return fmt.Sprintf("%v", []Uint8Option(o))
}

// Append will add the provided uint8 to the slice with NewUint8Option
func (o ListUint8Option) Append(values ...uint8) ListUint8Option {
	results := o
	for _, val := range values {
		results = append(results, NewUint8Option(val))
	}
	return results
}

// Slice returns raw []uint8 data stored in the ListUint8Option
func (o ListUint8Option) Slice() []uint8 {
	tmp := []uint8{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListUint8Option has one or more options
// in the slice.
func (o ListUint8Option) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}

// UintptrOption hold data for configuration fields of type uintptr
type UintptrOption struct {
	Source  string
	Defined bool
	Value   uintptr
}

// NewUintptrOption returns a default configuration object of type uintptr
func NewUintptrOption(dflt uintptr) UintptrOption {
	return UintptrOption{
		Source:  "default",
		Defined: true,
		Value:   dflt,
	}
}

// IsDefined returns if the option has been defined (things returned from
// NewUintptrOption are defined by default)
func (o UintptrOption) IsDefined() bool {
	return o.Defined
}

// SetSource allows setting the config file source path for the option
func (o *UintptrOption) SetSource(source string) {
	o.Source = source
}

// GetSource returns the config file source path for the option
func (o *UintptrOption) GetSource() string {
	return o.Source
}

// GetValue returns the raw value (type uintptr) of the option
func (o UintptrOption) GetValue() interface{} {
	return o.Value
}

// Set allows setting the value from a string.  It will be parsed from a string
// into the uintptr.  This is useful with kingpin option parser
func (o *UintptrOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *UintptrOption) WriteAnswer(name string, value interface{}) error {
	if v, ok := value.(uintptr); ok {
		o.Value = v
		o.Defined = true
		o.Source = "prompt"
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, o.Value, value)
}

// SetValue will set the option value from the provided interface. The interface
// value must be of type uintptr.
func (o *UintptrOption) SetValue(v interface{}) error {
	if val, ok := v.(uintptr); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

// UnmarshalYAML will populate the option from the parsed results of the
// yaml unmarshaller.
func (o *UintptrOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err != nil {
		return err
	}
	o.Source = "yaml"
	o.Defined = true
	return nil
}

// UnmarshalJSON will populate the option from the parsed results for the
// json unmarshaller.
func (o *UintptrOption) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, &o.Value); err != nil {
		return err
	}
	o.Source = "json"
	o.Defined = true
	return nil
}

// MarshalYAML will convert the option to the uintptr value when marshalling
// the data structure.
func (o UintptrOption) MarshalYAML() (interface{}, error) {
	if StringifyValue {
		return o.Value, nil
	}
	// need a copy of this struct without the MarshalYAML interface attached
	return struct {
		Value   uintptr
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	}, nil
}

// MarshalJSON will convert the option to the uintptr value when marshalling
// the data structure.
func (o UintptrOption) MarshalJSON() ([]byte, error) {
	if StringifyValue {
		return json.Marshal(o.Value)
	}
	// need a copy of this struct without the MarshalJSON interface attached
	return json.Marshal(struct {
		Value   uintptr
		Source  string
		Defined bool
	}{
		Value:   o.Value,
		Source:  o.Source,
		Defined: o.Defined,
	})
}

// String is required for kingpin to generate usage with this datatype
func (o UintptrOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

// MapUintptrOption is a map of options.
type MapUintptrOption map[string]UintptrOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *MapUintptrOption) Set(value string) error {
	parts := stringMapRegex.Split(value, 2)
	if len(parts) != 2 {
		return fmt.Errorf("expected KEY=VALUE got '%s'", value)
	}
	val := UintptrOption{}
	val.Set(parts[1])
	(*o)[parts[0]] = val
	return nil
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o MapUintptrOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o MapUintptrOption) String() string {
	return fmt.Sprintf("%v", map[string]UintptrOption(o))
}

// Map will return a raw map from the Option.
func (o MapUintptrOption) Map() map[string]uintptr {
	tmp := map[string]uintptr{}
	for k, v := range o {
		tmp[k] = v.Value
	}
	return tmp
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *MapUintptrOption) WriteAnswer(name string, value interface{}) error {
	tmp := UintptrOption{}
	if v, ok := value.(uintptr); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		(*o)[name] = tmp
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsDefined will return true if there is more than one key set in the map.
func (o MapUintptrOption) IsDefined() bool {
	// true if the map has any keys
	return len(o) > 0
}

// ListUintptrOption is a slice of UintptrOption
type ListUintptrOption []UintptrOption

// Set is required for kingpin interfaces to allow command line params
// to be set to our map datatype
func (o *ListUintptrOption) Set(value string) error {
	val := UintptrOption{}
	val.Set(value)
	*o = append(*o, val)
	return nil
}

// WriteAnswer will assign the option value from the value provided during
// a prompt.  This is useful with survey prompting library
func (o *ListUintptrOption) WriteAnswer(name string, value interface{}) error {
	tmp := UintptrOption{}
	if v, ok := value.(uintptr); ok {
		tmp.Value = v
		tmp.Defined = true
		tmp.Source = "prompt"
		*o = append(*o, tmp)
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", value, tmp.Value, value)
}

// IsCumulative is required for kingpin interfaces to allow multiple values
// to be set on the data structure.
func (o ListUintptrOption) IsCumulative() bool {
	return true
}

// String is required for kingpin to generate usage with this datatype
func (o ListUintptrOption) String() string {
	return fmt.Sprintf("%v", []UintptrOption(o))
}

// Append will add the provided uintptr to the slice with NewUintptrOption
func (o ListUintptrOption) Append(values ...uintptr) ListUintptrOption {
	results := o
	for _, val := range values {
		results = append(results, NewUintptrOption(val))
	}
	return results
}

// Slice returns raw []uintptr data stored in the ListUintptrOption
func (o ListUintptrOption) Slice() []uintptr {
	tmp := []uintptr{}
	for _, elem := range o {
		tmp = append(tmp, elem.Value)
	}
	return tmp
}

// IsDefined will return true if the ListUintptrOption has one or more options
// in the slice.
func (o ListUintptrOption) IsDefined() bool {
	// true if the list is not empty
	return len(o) > 0
}
